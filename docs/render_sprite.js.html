<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: render/sprite.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: render/sprite.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { GameComponent } from '../core';

  /**
   * Component for rendering backgrounds for example.
   * @extends {GameComponent}
   * @param {RenderSystem} renderSystem - Where to draw.
   * @param {object} texture - A texture object i.e {image: new Image(), width: 0, height: 0}
   * @param {array} bounds - How far and wide to render the images. Guaranteed to cover bounds.
   */
  export class TileComponent extends GameComponent{
    constructor (renderSystem, texture, bounds) {
      super();

      this.renderSystem = renderSystem;
      this.texture = texture;
      this.bounds = bounds;
    }

    update (parent, delta) {
      var renderSystem = this.renderSystem,
          texture = this.texture,
          bounds = this.bounds,
          dx = texture.width,
          dy = texture.height,
          startX = parent.position[0] % dx,
          startY = parent.position[1] % dy,
          x,
          y = bounds[1],// + startY - dy,
          width = bounds[2],
          height = bounds[3],
          render = function(texture, x, y){
            return function(context){
              context.drawImage(texture.image, x, y);
            };
          };
      for(; y &lt; height + dy; y += dy){
        for(x = bounds[0] + startX - dx; x &lt; width + dx; x += dx){
          renderSystem.push(render(texture, x, y));
        }
      }
    }
  }

  /**
   * Sprite Object Definition
   * ------------------------
   *
   * let sprite = {
   *    t:  texture object (i.e. {image: new Image(), width: 0, height: 0, loaded: false})
   *    x:  X-offset of sprite in spritesheet
   *    y:  Y-offset of sprite in spritesheet
   *    w:  width of sprite
   *    h:  height of sprite
   *    ox: origin x-offset, so sprite can be centred on parent's position
   *    oy: origin y-offset, so sprite can be centred on parent's position
   *    d:  (optional) duration of sprite for animation
   * }
   */

  /**
   * Component renders a sprite for a parent object.
   *
   * Component can either contain its own sprite or use one provided on the parent.
   * In the case where both component and parent have sprites, the one on the parent
   * is prefered.
   * @extends {GameComponent}
   */
  export class SpriteRenderingComponent extends GameComponent {
    constructor (renderSystem, layer, sprite){
      super();

      this.renderSystem = renderSystem;
      this.layer = layer;
      this.sprite = sprite;
    }

    update (parent, delta) {
      super.update(delta);

      var sprite = this.sprite || parent.sprite,
          image = sprite &amp;&amp; sprite.t.image;

      if(sprite){
        this.renderSystem.push(function(context){
          var x = parent.position[0],
              y = parent.position[1],
              w = sprite.w,
              h = sprite.h;
          context.translate(x,y);
          context.rotate(parent.rotation);
          context.drawImage(image, sprite.x, sprite.y, w, h, -sprite.ox, -sprite.oy, w, h);
        }, this.layer);
      }
    }
  }

  /**
   * Animate through a sequence of sprites.
   * @extends {GameComponent}
   * @param {number} duration - Default duration if sprites do no contain their own intrinsic duration.
   * @param {array} sprites - Array of sprite objects.
   */
  export class SpriteAnimationComponent extends GameComponent {
    constructor (duration, sprites) {
      super();
      this.duration = duration;
      this.spriteIndex = 0;
      this.playing = true;
      this.sprites = sprites;
    }

    init (parent) {
      if(this.sprites) {
        parent.sprites = this.sprites;
      }
      if(parent.sprites.length){
        parent.sprite = parent.sprites[0];
      }
      parent.spriteCountdown = (parent.sprite &amp;&amp; parent.sprite.d) || this.duration;
    }

    update (parent, delta) {
      var spriteCount = parent.sprites.length,
          sprite,
          duration;

      if(this.playing){
        parent.spriteCountdown -= delta;
        if(parent.spriteCountdown &lt;= 0){
          // TODO: Possible divide by zero
          this.spriteIndex = (this.spriteIndex + 1) % spriteCount;
          sprite = parent.sprites[this.spriteIndex];
          parent.sprite = sprite;
          duration = sprite.d || this.duration;
          parent.spriteCountdown = duration;
        }
      }
    }

    /**
     * Start the animation.
     */
    play() {
      this.playing = true;
    }

    /**
     * Stop the animation and reset the frame to the first sprite.
     */
    stop () {
      this.playing = false;
      this.spriteIndex = 0;
    }

    /**
     * Pause the animation.
     */
    pause () {
      this.playing = false;
    }
  }

  /** @static */
  export const Sprite = {};

  /**
   * Convenience method to generate a set of sprite objects based on a template and a spritesheet.
   * @static
   * @param {object} sprite - The sprite template.
   * @param {number} rows - Number of rows in the sprite sheet.
   * @param {number} cols - Number of columns in the sprite sheet.
   */
  Sprite.generateSpriteSheet = function(sprite, rows, cols){
    var out = [],
        i,
        j;
    for(i=0; i&lt;rows; i++){
      for(j=0; j&lt;cols; j++){
        out.push({
          t: sprite.t,
          x: j*sprite.w,
          y: i*sprite.h,
          w: sprite.w,
          h: sprite.h,
          ox: sprite.ox,
          oy: sprite.oy,
          d: sprite.d
        });
      }
    }
    return out;
  };

  /**
   * This component is not to be used any more. Use Sprite animation component instead
   * @constructor
   * @deprecated
   * @extends {GameComponent}
   */
  export function AnimatedSpriteComponent(images, speed){
    this.images = images;
    this.delay = 1000 / speed;
    this.lastChange = 0;
    this.imageIndex = 0;
  }
  AnimatedSpriteComponent.prototype = new GameComponent();
  AnimatedSpriteComponent.prototype.update = function(parent, delta) {
    if(this.lastChange > this.delay){
      this.imageIndex = (this.imageIndex + 1) % this.images.length;
      parent.sprite = this.images[this.imageIndex];
      this.lastChange = 0;
    } else {
      this.lastChange += delta;
    }
  };

  /**
   * This component is not to be used any more. Use other components instead
   * @constructor
   * @deprecated
   * @extends {GameComponent}
   */
  export function CanvasSpriteRenderingComponent(renderSystem){
    this.renderSystem = renderSystem;
  }
  CanvasSpriteRenderingComponent.prototype = new GameComponent();
  CanvasSpriteRenderingComponent.prototype.update = function(parent, delta) {
    this.renderSystem.push(function(context){
      var x = parent.position[0],
          y = parent.position[1],
          w = parent.sprite.width,
          h = parent.sprite.height;
      context.translate(x,y);
      context.rotate(parent.rotation);
      context.drawImage(parent.sprite,-w/2,-h/2);
    });
  };
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AnimatedSpriteComponent.html">AnimatedSpriteComponent</a></li><li><a href="AudioSystem.html">AudioSystem</a></li><li><a href="BounceComponent.html">BounceComponent</a></li><li><a href="CameraSystem.html">CameraSystem</a></li><li><a href="CanvasRenderSystem.html">CanvasRenderSystem</a></li><li><a href="CanvasSpriteRenderingComponent.html">CanvasSpriteRenderingComponent</a></li><li><a href="CollisionComponent.html">CollisionComponent</a></li><li><a href="CollisionSystem.html">CollisionSystem</a></li><li><a href="DebugDrawBoundsComponent.html">DebugDrawBoundsComponent</a></li><li><a href="DebugFlockingComponent.html">DebugFlockingComponent</a></li><li><a href="FlockingComponent.html">FlockingComponent</a></li><li><a href="Game.html">Game</a></li><li><a href="GameComponent.html">GameComponent</a></li><li><a href="GameObject.html">GameObject</a></li><li><a href="GameObjectManager.html">GameObjectManager</a></li><li><a href="GravityComponent.html">GravityComponent</a></li><li><a href="InputSystem.html">InputSystem</a></li><li><a href="MoveComponent.html">MoveComponent</a></li><li><a href="PhysicsComponent.html">PhysicsComponent</a></li><li><a href="SolidComponent.html">SolidComponent</a></li><li><a href="SpriteAnimationComponent.html">SpriteAnimationComponent</a></li><li><a href="SpriteRenderingComponent.html">SpriteRenderingComponent</a></li><li><a href="SwitchComponent.html">SwitchComponent</a></li><li><a href="TerminalVelocityComponent.html">TerminalVelocityComponent</a></li><li><a href="TileComponent.html">TileComponent</a></li><li><a href="WorldBounceComponent.html">WorldBounceComponent</a></li><li><a href="WorldSystem.html">WorldSystem</a></li><li><a href="WorldWrapComponent.html">WorldWrapComponent</a></li></ul><h3>Global</h3><ul><li><a href="global.html#simplifyPaths">simplifyPaths</a></li><li><a href="global.html#Sprite">Sprite</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Wed Jan 25 2017 18:16:40 GMT+0800 (China Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
