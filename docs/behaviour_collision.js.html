<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: behaviour/collision.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: behaviour/collision.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import GameObject from '../core/GameObject';
import GameComponent from '../core/GameComponent';
import { vec2, vec3 } from 'gl-matrix';

/**
 * This system's purpose is to accept 'attack' and 'vulnerable' bounds to be submitted
 * then once per frame sweep these to find intersections. Any which are found are then
 * reported to the respective objects.
 * @extends {GameObject}
 */
export class CollisionSystem extends GameObject {
	constructor () {
		super();

		this.attackObjects = [];
		this.vulnerableObjects = [];
	}

	addAttackObject (object){
		this.attackObjects.push(object);
	}

	addVulnerableObject (object){
		this.vulnerableObjects.push(object);
	}

	update (delta) {
		const attackCount = this.attackObjects.length;
		const vulnerableCount = this.vulnerableObjects.length;


		for(let i = 0; i &lt; attackCount; i++){
			const attack = this.attackObjects[i];
			const ax = attack.position[0];
			const ay = attack.position[1];
			const ab = attack.bounds;
			const attackBounds = [
				ax + ab[0],
				ay + ab[1],
				ax + ab[2],
				ay + ab[3]
			];

			for(let j = 0; j &lt; vulnerableCount; j++){
				const vulnerable = this.vulnerableObjects[j];
				const vx = vulnerable.position[0];
				const vy = vulnerable.position[1];
				const vb = vulnerable.bounds;
				const vulnerableBounds = [
					vx + vb[0],
					vy + vb[1],
					vx + vb[2],
					vy + vb[3]
				];

				if(attack === vulnerable) {
					continue;
				}

				if(attackBounds[0] &lt; vulnerableBounds[2] &amp;&amp;
					attackBounds[1] &lt; vulnerableBounds[3] &amp;&amp;
					attackBounds[2] > vulnerableBounds[0] &amp;&amp;
					attackBounds[3] > vulnerableBounds[1] ) {

					attack.fire("attack", vulnerable);
					vulnerable.fire("attackedBy", attack);
				}
			}
		}
		this.attackObjects.length = 0;
		this.vulnerableObjects.length = 0;
	};
}

/**
 * Component to interface with collision system. Handles both attack
 * and vulnerable configurations.
 * @extends {GameComponent}
 * @param {CollisionSystem} collisionSystem - Which CollisionSystem to report to
 * @param {boolean} attack - Can this object attack?
 * @param {boolean} vulnerable - Is this object vulnerable?
 */
export class CollisionComponent extends GameComponent {

	constructor (collisionSystem, attack, vulnerable) {
		super();

		this.collisionSystem = collisionSystem;
		this.attack = attack;
		this.vulnerable = vulnerable;
	}

	update (parent, delta){
		if(this.attack)
			this.collisionSystem.addAttackObject(parent);

		if(this.vulnerable)
			this.collisionSystem.addVulnerableObject(parent);
	}
}

const sCBVdelta = vec3.create();
const sCBVmtd = vec3.create();
const sCBVv = vec3.create();
const sCBVmtdNorm = vec3.create();
const sCBVimpulse = vec3.create();

/**
 * Component which allows collided objects to bounce off one-another. Respects
 * conservation of momentum.
 * @extends {GameComponent}
 */
export class BounceComponent extends GameComponent {
	constructor () {
		super();
		this.cRestitution = 0.9;
	}

	init (parent) {
		parent.on("attack", other => {

			const aWidth = parent.bounds[2] - parent.bounds[0];
			const aHeight = parent.bounds[3] - parent.bounds[1];
			const bWidth = other.bounds[2] - other.bounds[0];
			const bHeight = other.bounds[3] - other.bounds[1];
			const aRad = (aWidth + aHeight) / 2;
			const bRad = (bWidth + bHeight) / 2;

			const minDist = (aRad + bRad) / 2;
            const curDist = vec3.dist(parent.position, other.position);

			if(curDist &lt; minDist){
				// http://stackoverflow.com/q/345838
				// get the mtd
				vec3.subtract(sCBVdelta, parent.position, other.position);

				// minimum translation distance to push balls apart after intersecting
				vec3.scale(sCBVmtd, sCBVdelta, (minDist - curDist) / curDist);

				// resolve intersection --
				// inverse mass quantities
				const im1 = 1 / (parent.mass || 1);
				const im2 = 1 / (other.mass || 1);

				// push-pull them apart based off their mass
				vec3.scaleAndAdd(parent.position, parent.position, sCBVmtd, im1 / (im1 + im2));
				vec3.scaleAndAdd(other.position, other.position, sCBVmtd, -im2 / (im1 + im2));

				// impact speed
				vec3.subtract(sCBVv, parent.velocity, other.velocity);
				vec3.normalize(sCBVmtdNorm, sCBVmtd);
				const vn = vec3.dot(sCBVv, sCBVmtdNorm)

				// sphere intersecting but moving away from each other already
				if (vn > 0) return;

				// collision impulse
				const i = (-(1 + this.cRestitution) * vn) / (im1 + im2);
				vec3.scale(sCBVimpulse, sCBVmtdNorm, i);

				// change in momentum
				vec3.scaleAndAdd(parent.velocity, parent.velocity, sCBVimpulse, im1);
				vec3.scaleAndAdd(other.velocity, other.velocity, sCBVimpulse, -im2);
			}
		});
	}
}

	export function BackgroundCollisionSystem() {
		GameObject.call(this); // Remember parent constructor
		this.surfaces = [];
	}
	BackgroundCollisionSystem.prototype = new GameObject();
	BackgroundCollisionSystem.prototype.addSurface = function(surface) {
		this.surfaces.push(surface);
	};
	BackgroundCollisionSystem.prototype.addSurfaces = function(surfaces) {
		for(var i = 0; i &lt; surfaces.length; i++){
			this.surfaces.push(surfaces[i]);
		}
	};
	BackgroundCollisionSystem.prototype.clearSurfaces = function(){
		this.surfaces.length = 0;
	};
	BackgroundCollisionSystem.prototype.update = function(delta) {
		// Background System updates
		GameObject.prototype.update.call(this, delta);
	};

	var u = vec2.create(),
			n = vec2.create(),
			w = vec2.create(),
			p = vec2.create(),
			r = vec2.create(),
			q = vec2.create(),
			s = vec2.create(),
			q_p = vec2.create(),
			v = vec2.create();

	export function BackgroundCollisionComponent(backgroundSystem, collisionBounds) {
		this.backgroundSystem = backgroundSystem;
		this.bounds = collisionBounds;
	}
	BackgroundCollisionComponent.prototype = new GameComponent();
	BackgroundCollisionComponent.prototype.update = function(parent, delta)
	{
		// This logic should probably be moved to BackgroundCollisionSystem
		var surfaces = this.backgroundSystem.surfaces,
			j = 0,
			m = surfaces.length,
			c, l,
			i,
			p_t,
			p_u,
			//theta,
			f = 0.95,
			e = 0.4,
			parentX = parent.position[0],
			parentY = parent.position[1];
		if(this.lastX &amp;&amp;
				Math.abs(this.lastX - parentX) &lt; 100 &amp;&amp;
				Math.abs(this.lastY - parentY) &lt; 100){
			for(;j&lt;m;j++){
				c = surfaces[j],
				l = c.length;
				for(i=0; i&lt;l-3;i+=2)
				{
					// http://stackoverflow.com/questions/563198/how-do-you-detect-where-two-line-segments-intersect
					vec2.set(p, c[i  ], c[i+1]);
					vec2.set(r, c[i+2], c[i+3]);
					vec2.subtract(r, r, p);
					vec2.set(q, this.lastX, this.lastY);
					vec2.subtract(s, parent.position, q);
					//theta = s.angle();
					//s.add(0,this.bounds*Math.cos(theta));
					vec2.subtract(q_p, q, p);
					p_t = cross(q_p, s) / cross(r, s);
					p_u = cross(q_p, r) / cross(r, s);
					if(p_t >= 0 &amp;&amp; p_t &lt;= 1 &amp;&amp; p_u >= 0 &amp;&amp; p_u &lt;= 1)
					{
						parent.position[0] = this.lastX;
						parent.position[1] = this.lastY;
						// http://stackoverflow.com/questions/573084/how-to-calculate-bounce-angle
						vec2.set(n, -r[1], r[0]); // this is the normal to the surface
						vec2.normalize(n, n);
						vec2.copy(v, parent.velocity);
						vec2.scale(u, n, vec2.dot(n, v));
						vec2.subtract(w, v, u);
						vec2.scale(w, w, f);
						vec2.scale(u, u, e);
						vec2.subtract(parent.velocity, w, u);
						break;
					}
				}
			}
		}
		this.lastX = parent.position[0];
		this.lastY = parent.position[1];
	};

	function cross(a, b){
		return a[0]*b[1] - a[1]*b[0];
	}

	export function DrawSurfacesComponent(renderSystem, colour){
		this.renderSystem = renderSystem;
		this.colour = colour || "#000";
	}
	GameComponent.create(DrawSurfacesComponent,{
		update: function(parent, delta){
			var s = parent.surfaces,
				j = 0,
				m = s.length,
				i, c, l;
			for(; j&lt;m; j++){
				this.renderSystem.strokePath(s[j], parent.colour || this.colour);
			}

			// Draw Normals
			if(GE.DEBUG){
				for(j=0; j&lt;m; j++){
					c = parent.surfaces[j];
					l = c.length;
					for(i=0;i&lt;l-3;i+=2){
						var x1 = c[i],
							y1 = c[i+1],
							x2 = c[i+2],
							y2 = c[i+3],
							dx = x2 - x1,
							dy = y2 - y1,
							mx = x1 + dx * 0.5,
							my = y1 + dy * 0.5,
							nx = dy / Math.sqrt(dy * dy + dx * dx),
							ny = -dx / Math.sqrt(dy * dy + dx * dx);
						this.renderSystem.strokePath([mx,my,mx+nx*30,my+ny*30],'#08f');
					}
				}
			}
		}
	});
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AnimatedSpriteComponent.html">AnimatedSpriteComponent</a></li><li><a href="AudioSystem.html">AudioSystem</a></li><li><a href="BounceComponent.html">BounceComponent</a></li><li><a href="CameraSystem.html">CameraSystem</a></li><li><a href="CanvasRenderSystem.html">CanvasRenderSystem</a></li><li><a href="CanvasSpriteRenderingComponent.html">CanvasSpriteRenderingComponent</a></li><li><a href="CollisionComponent.html">CollisionComponent</a></li><li><a href="CollisionSystem.html">CollisionSystem</a></li><li><a href="DebugDrawBoundsComponent.html">DebugDrawBoundsComponent</a></li><li><a href="DebugFlockingComponent.html">DebugFlockingComponent</a></li><li><a href="FlockingComponent.html">FlockingComponent</a></li><li><a href="Game.html">Game</a></li><li><a href="GameComponent.html">GameComponent</a></li><li><a href="GameObject.html">GameObject</a></li><li><a href="GameObjectManager.html">GameObjectManager</a></li><li><a href="GravityComponent.html">GravityComponent</a></li><li><a href="InputSystem.html">InputSystem</a></li><li><a href="MoveComponent.html">MoveComponent</a></li><li><a href="PhysicsComponent.html">PhysicsComponent</a></li><li><a href="SolidComponent.html">SolidComponent</a></li><li><a href="SpriteAnimationComponent.html">SpriteAnimationComponent</a></li><li><a href="SpriteRenderingComponent.html">SpriteRenderingComponent</a></li><li><a href="SwitchComponent.html">SwitchComponent</a></li><li><a href="TerminalVelocityComponent.html">TerminalVelocityComponent</a></li><li><a href="TileComponent.html">TileComponent</a></li><li><a href="WorldBounceComponent.html">WorldBounceComponent</a></li><li><a href="WorldSystem.html">WorldSystem</a></li><li><a href="WorldWrapComponent.html">WorldWrapComponent</a></li></ul><h3>Global</h3><ul><li><a href="global.html#simplifyPaths">simplifyPaths</a></li><li><a href="global.html#Sprite">Sprite</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Wed Jan 25 2017 18:16:40 GMT+0800 (China Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
