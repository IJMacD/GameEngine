<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: misc.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: misc.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>(function(){
	Array.prototype.remove = function(from, to) {
		var rest = this.slice((to || from) + 1 || this.length);
		this.length = from &lt; 0 ? this.length + from : from;
		return this.push.apply(this, rest);
	};
	function drawCircle(ctx, x, y, r){
		ctx.beginPath();
		ctx.arc(x, y, r, 0, Math.PI * 2);
	};
	function drawEllipse(ctx, x, y, xr, yr){
	  var kappa = .5522848;
		  ox = xr * kappa, // control point offset horizontal
		  oy = yr * kappa, // control point offset vertical
		  xe = x + xr;       // x-end
		  ye = y + yr,       // y-end
		  xs = x - xr,       // x-start
		  ys = y - yr;       // y-start

	  ctx.beginPath();
	  ctx.moveTo(xs, y);
	  ctx.bezierCurveTo(xs, y - oy, x - ox, ys, x, ys);
	  ctx.bezierCurveTo(x + ox, ys, xe, y - oy, xe, y);
	  ctx.bezierCurveTo(xe, y + oy, x + ox, ye, x, ye);
	  ctx.bezierCurveTo(x - ox, ye, xs, y + oy, xs, y);
	  ctx.closePath();
	};
	CanvasRenderingContext2D.prototype.strokeCircle = function(x, y, radius){
		drawCircle(this, x, y, radius);
		this.stroke();
	};
	CanvasRenderingContext2D.prototype.fillCircle = function(x, y, radius){
		drawCircle(this, x, y, radius);
		this.fill();
	};
	CanvasRenderingContext2D.prototype.strokeEllipse = function(x, y, xr, yr) {
		drawEllipse(this, x, y, xr, yr);
		this.stroke();
	};
	CanvasRenderingContext2D.prototype.fillEllipse = function(x, y, xr, yr) {
		drawEllipse(this, x, y, xr, yr);
		this.fill();
	};
	Function.prototype.extend = function(name) {
		function Class() {
			if (!(this instanceof Class))
				throw('Constructor called without "new"');
			if ('_init' in this)
				this._init.apply(this, arguments);
			this.name = name;
		}
		Function.prototype.extend.nonconstructor.prototype = this.prototype;
		Class.prototype = new Function.prototype.extend.nonconstructor();
		return Class;
	};
	Function.prototype.extend.nonconstructor= function() {};
})();
// -----------------
// Define Components
// -----------------


var CanvasManager = GameObject.extend("CanvasManager");
CanvasManager.prototype._init = function(context){
	GameObject.prototype._init.call(this);
	this.context = context;
};
CanvasManager.prototype.update = function(delta){
	width = this.context.canvas.width = this.context.canvas.offsetWidth;
	height = this.context.canvas.height = this.context.canvas.offsetHeight;
}

var DrawBallComponent = GameComponent.extend("DrawBallComponent");
DrawBallComponent.prototype._init = function(size, colour){
	this.size = size;
	this.colour = colour;
};
DrawBallComponent.prototype.update = function(parent, delta) {
	GameObject.sRenderSystem.fillCircle(parent.position.x,parent.position.y,this.size,this.colour);
	GameObject.sRenderSystem.fillCircle(parent.position.x+this.size*0.33,parent.position.y-this.size*0.33,this.size*0.45,"rgba(255,255,255,0.7)");
};
var DrawPolygonComponent = GameComponent.extend("DrawPolygonComponent");
DrawPolygonComponent.prototype._init = function(coords, colour, fill){
	this.coords = coords;
	this.colour = colour;
	this.fill = fill;
	this.vec = new Vector2();
};
DrawPolygonComponent.prototype.update = function(parent, delta) {
	var i=0,
		l = this.coords.length-1,
		path = [];
	for(;i&lt;l;i+=2){
		this.vec.set(this.coords[i],this.coords[i+1]);
		this.vec.leftMultiply(Matrix.rotationMatrix(parent.rotation));
		this.vec.add(parent.position);
		path.push(this.vec.x, this.vec.y);
	}
	GameObject.sRenderSystem.strokePath(path,this.colour);
};





PointGravityComponent.referencesTest = function(object){
	return function(testComponent){
		return testComponent instanceof PointGravityComponent &amp;&amp;
			testComponent.target == object;
	};
};
var GeneralRelativityPointGravityComponent = GameComponent.extend("GeneralRelativityPointGravityComponent");
GeneralRelativityPointGravityComponent.prototype._init = function(target) {
	this.target = target;
	this.vectorA = new Vector2();
	this.vectorB = new Vector2();
};
GeneralRelativityPointGravityComponent.prototype.update = function(parent, delta) {
	var r = this.vectorA.set(parent.position).subtract(this.target.position),
		v = this.vectorB.set(parent.velocity),
		G = 1,
		M = this.target.mass,
		r2 = r.magnitude2(),
		r3 = Math.pow(r.magnitude(),3),
		v1 = v.magnitude(),
		c2 = 325334.92879081, // &lt;- this number here actually ties all units to real world
		newtonian = - G*M / r2,
		relativity = - 3*G*M / (r3 * c2) * v.dot(r);
	// just re-use r here
	r.normalise();
	r.scale(newtonian);
	// This line is part of GR calculations
	v.scale(relativity);
	r.add(v);
	r.scale(delta);
	parent.velocity.add(r);
};
GeneralRelativityPointGravityComponent.referencesTest = function(object){
	return function(testComponent){
		return testComponent instanceof GeneralRelativityPointGravityComponent &amp;&amp;
			testComponent.target == object;
	};
};
var CollisionComponent = GameComponent.extend("CollisionComponent");
CollisionComponent.prototype._init = function(width, height) {
	this.halfWidth = width / 2;
	this.halfHeight = height / 2;
};
CollisionComponent.prototype.update = function(parent, delta) {
	var bounds = [
		parent.position.x - this.halfWidth,
		parent.position.y - this.halfHeight,
		parent.position.x + this.halfWidth,
		parent.position.y + this.halfHeight
	];
	GameObject.sCollisionSystem.addCollisionBounds(parent, bounds, bounds);
};
var CollisionSystem = GameObject.extend("CollisionSystem");
CollisionSystem.prototype._init = function() {
	GameObject.prototype._init.call(this);
	this.attackBounds = [];
	this.vulnerableBounds = [];
};
CollisionSystem.prototype.update = function(delta) {
	GameObject.prototype.update.call(this,delta);

	var i = 0,
		l = this.attackBounds.length,
		j,
		m = this.vulnerableBounds.length,
		collision = false,
		attack, vulnerable;
	for(; i &lt; l; i++){
		attack = this.attackBounds[i];
		for(j=0; j &lt; m; j++){
			vulnerable = this.vulnerableBounds[j];
			if(attack.object != vulnerable.object &amp;&amp;
				attack.bounds[2] >= vulnerable.bounds[0] &amp;&amp;
				attack.bounds[0] &lt;= vulnerable.bounds[2] &amp;&amp;
				attack.bounds[3] >= vulnerable.bounds[1] &amp;&amp;
				attack.bounds[1] &lt;= vulnerable.bounds[3])
			{
				attack.object.hit(vulnerable.object);
				vulnerable.object.hitBy(attack.object);
				// break; here?
			}
		}
	}
	this.attackBounds = [];
	this.vulnerableBounds = [];
};
CollisionSystem.prototype.addCollisionBounds = function(object, attackBounds, vulnerableBounds){
	// These should be added sorted!!
	if(attackBounds &amp;&amp; attackBounds.length)
		this.attackBounds.push({object: object, bounds: attackBounds});
	if(vulnerableBounds &amp;&amp; vulnerableBounds.length)
		this.vulnerableBounds.push({object: object, bounds: vulnerableBounds});
};

/**
 * Submit surfaces to BackgroundCollisionSystem
 * @constructor
 */
var SolidComponent = GameComponent.extend("SolidComponent");
SolidComponent.prototype._init = function(lineSegments) {
	this.segments = lineSegments;
};
SolidComponent.prototype.update = function(parent, delta) {
	var lines = [],
		i = 0,
		l = this.segments.length,
		j, m,
		seg, line;
	for(;i&lt;l;i++){
		seg = this.segments[i];
		m = seg.length-1;
		line = []
		for(j=0;j&lt;m;j+=2){
			line.push(seg[j]+parent.position.x, seg[j+1]+parent.position.y);
		}
		lines.push(line);
	}
	GameObject.sBackgroundCollisionSystem.addTemporarySurfaces(lines);
};

var InputSystem = GameObject.extend("InputSystem");
InputSystem.prototype._init = function() {
	GameObject.prototype._init.call(this);
	this.hasInput = false;
	this.lastInput = null;
};
InputSystem.prototype.update = function(parent, delta) {
	//this.hasInput = false;
	this.hasKey = Math.max(--this.hasKey,0);
};
InputSystem.prototype.click = function(x,y){
	this.hasInput = true;
	this.lastInput = {x: x, y: y};
}
InputSystem.prototype.mouseDown = function(x,y){
	this.hasInput = true;
	this.lastInput = {x: x, y: y};
}
InputSystem.prototype.keyDown = function(keyCode){
	this.hasKey = 2;
	this.keyCode = keyCode;
}
var MoveToClickComponent = GameComponent.extend("MoveToClickComponent");
MoveToClickComponent.prototype.update = function(parent, delta) {
	if(sInputSystem.hasInput){
		parent.position.set(sInputSystem.lastInput);
		sInputSystem.hasInput = false;
	}
};
var AirResistanceComponent = GameComponent.extend("AirResistanceComponent");
AirResistanceComponent.prototype._init = function(csa,rho) {
	this.csa = csa;
	this.rho = typeof rho == "number" ? rho : 0.001;
};
AirResistanceComponent.prototype.update = function(parent,delta) {
	var mag2 = parent.velocity.magnitude2(),
		scalar = 1-mag2*this.rho*this.csa*delta;
	parent.velocity.scale(scalar);
	return;
	var	dvx = Math.abs(Math.sin(theta)*dv),
		dvy = Math.abs(Math.cos(theta)*dv);
		// Math.abs... Math.min....
	if(dvx > Math.abs(parent.vx))
		parent.vx = 0;
	else
		parent.vx = parent.vx + (parent.vx &lt; 0 ? dvx : -dvx);
	if(dvy > Math.abs(parent.vy))
		parent.vy = 0;
	else
		parent.vy = parent.vy + (parent.vy &lt; 0 ? dvy : -dvy);
};
var DebugDrawDataComponentCount = 0,
	DebugDrawDataComponent = GameComponent.extend("DebugDrawDataComponent");
DebugDrawDataComponent.prototype._init = function(context, desc) {
	this.context = context;
	this.desc = desc;
	this.xOffset = DebugDrawDataComponentCount * 70 + 10;
	DebugDrawDataComponentCount++;
	this.maxX = this.maxY = this.maxVx = this.maxVy = this.maxV = 0;
};
DebugDrawDataComponent.prototype.update = function(parent, delta) {
	if(DEBUG){
		this.maxX = Math.max(this.maxX, parent.position.x);
		this.maxY = Math.max(this.maxY, parent.position.y);
		this.maxVx = Math.max(this.maxVx, parent.velocity.x);
		this.maxVy = Math.max(this.maxVy, parent.velocity.y);
		this.maxV = Math.max(this.maxV,parent.velocity.magnitude());
		this.context.fillStyle = "#999";
		var y = 0;
		if(typeof this.desc == "string")
			this.context.fillText(this.desc, this.xOffset, y+=15);
		this.context.fillText("x: " + parent.position.x.toFixed(), this.xOffset, y+=15);
		this.context.fillText("y: " + parent.position.y.toFixed(), this.xOffset, y+=15);
		this.context.fillText("vx: " + parent.velocity.x.toFixed(3), this.xOffset, y+=15);
		this.context.fillText("vy: " + parent.velocity.y.toFixed(3), this.xOffset, y+=15);
		this.context.fillText("v: " + parent.velocity.magnitude().toFixed(3), this.xOffset, y+=15);
		this.context.fillText("max x: " + this.maxX.toFixed(), this.xOffset, y+=15);
		this.context.fillText("max y: " + this.maxY.toFixed(), this.xOffset, y+=15);
		this.context.fillText("max vx: " + this.maxVx.toFixed(3), this.xOffset, y+=15);
		this.context.fillText("max vy: " + this.maxVy.toFixed(3), this.xOffset, y+=15);
		this.context.fillText("max v: " + this.maxV.toFixed(3), this.xOffset, y+=15);
	}
};
var GravitateToClickComponent = GameComponent.extend("GravitateToClickComponent");
GravitateToClickComponent.prototype._init = function() {
	this.vector = new Vector2();
};
GravitateToClickComponent.prototype.update = function(parent, delta){
	if(sInputSystem.hasInput){
		var acc = this.vector;
		acc.set(sInputSystem.lastInput).set(parent.position);
		acc.normalise();
		acc.scale(0.001*delta);
		parent.velocity.add(acc);
	}
}
var DebugDrawGraphComponentCount = 0,
	DebugDrawGraphComponent = GameComponent.extend("DebugDrawGraphComponent"),
	DebugDrawGraphComponentMin,
	DebugDrawGraphComponentMax = 0;
DebugDrawGraphComponent.prototype._init = function(context, evaluate) {
	if(typeof evaluate != "function")
		evaluate = function(object){return object.x};
	this.context = context;
	this.evaluate = evaluate;
	this.values = [];
	this.valueIndex = 0;
	this.average = [];
	this.averageSize = 4;
	this.valueSize = height*this.averageSize;
	this.offsetX = 50 * DebugDrawGraphComponentCount;
	this.localMax = 0;
	this.localMaxAt = 0;
	DebugDrawGraphComponentCount++;
};
DebugDrawGraphComponent.prototype.update = function(parent, delta) {
	if(DEBUG){
		var skip = this.valueIndex % this.valueSize,
			v = this.evaluate(parent,delta),
			x,
			y = height,
			scale;
		if(typeof DebugDrawGraphComponentMin == "undefined")
			DebugDrawGraphComponentMin = v;
		if(index == this.localMaxAt)
			DebugDrawGraphComponentMax = v;
		DebugDrawGraphComponentMin = Math.min(DebugDrawGraphComponentMin, v);
		DebugDrawGraphComponentMax = Math.max(DebugDrawGraphComponentMax, v);
		scale = 50 / (DebugDrawGraphComponentMax - DebugDrawGraphComponentMin);
		x = this.offsetX + (v - DebugDrawGraphComponentMin) * scale;
		this.context.strokeStyle = "#F88";
		this.context.beginPath();
		this.context.moveTo(x, y);
		var limit = (this.valueIndex > this.valueSize) ? this.valueSize-1 : this.valueIndex-1;
		for(var i = limit;i>=0;i-=this.averageSize){
			var index = (this.valueIndex > this.valueSize) ?
					(i + skip + this.valueSize) % this.valueSize : i,
				avgSum = 0,
				avg,
				val;
			for(var j = 0; j &lt; this.averageSize; j++){
				val = this.values[(index-j+this.valueSize)%this.valueSize];
				avgSum += val;
				if(val > this.localMax){
					this.localMax = val;
					this.localMaxAt = (index-j+this.valueSize)%this.valueSize;
				}
			}
			avg = avgSum / this.averageSize;
			x = this.offsetX + (avg - DebugDrawGraphComponentMin) * scale;
			y--;
			this.context.lineTo(x,y);
		}
		this.context.stroke();
		this.valueIndex++;
		this.values[skip] = v;
	}
};
DebugDrawGraphComponent.Velocity = function(object){return object.velocity.magnitude()};
DebugDrawGraphComponent.VelocityAngle = function(object){return object.velocity.angle()};
DebugDrawGraphComponent.Acceleration = function(){
	var lastV = new Vector2(),
		vector = new Vector2();
	return function(object, delta){
		vector.set(object.velocity).subtract(lastV).scale(1/delta);
		lastV.set(object.velocity);
		return vector.magnitude();
	}
}();
DebugDrawGraphComponent.AccelerationAngle = function(){
	var lastV = new Vector2(),
		vector = new Vector2();
	return function(object, delta){
		vector.set(object.velocity).subtract(lastV).scale(1/delta);
		lastV.set(object.velocity);
		return vector.angle();
	}
}();






var RenderSystem = GameObject.extend("RenderSystem");
(function(){
	RenderSystem.prototype._init = function(context) {
		GameObject.prototype._init.call(this);
		this.context = context;
	};
	function drawPath(context, path){
		var i = 2,
			l = path.length,
			v;
		context.beginPath();
		v = GameObject.sCameraSystem.worldToScreen(path[0],path[1]);
		context.moveTo(v.x,v.y);
		for(;i&lt;l-1;i+=2){
			v = GameObject.sCameraSystem.worldToScreen(path[i],path[i+1]);
			context.lineTo(v.x,v.y);
		}
	}
	RenderSystem.prototype.strokePath = function(path, style) {
		if(typeof style == "undefined")
			style = '#000';
		this.context.strokeStyle = style;
		drawPath(this.context, path);
		this.context.stroke();
	};
	RenderSystem.prototype.fillPath = function(path, style) {
		if(typeof style == "undefined")
			style = '#000';
		this.context.fillStyle = style;
		drawPath(this.context, path);
		this.context.fill();
	};
	RenderSystem.prototype.fillCircle = function(x,y,r, style){
		var v = GameObject.sCameraSystem.worldToScreen(x,y);
		this.context.fillStyle = style;
		this.context.fillCircle(v.x, v.y, r);
	};
	RenderSystem.prototype.strokeRect = function(x,y,w,h, style){
		var v = GameObject.sCameraSystem.worldToScreen(x,y);
		this.context.strokeStyle = style;
		this.context.strokeRect(v.x, v.y, w, h);
	};
	RenderSystem.prototype.drawSprite = function(x,y,sprite) {
		// body...
	};
})();
var FollowComponent = GameComponent.extend("FollowComponent");
FollowComponent.prototype._init = function(object) {
	this.target = object;
};
FollowComponent.prototype.update = function(parent, delta) {
	parent.position.set(this.target.position);
};




var DecayComponent = GameComponent.extend("DecayComponent");
DecayComponent.prototype._init = function(lifetime) {
	this.lifetime = lifetime;
	this.destroyOnTimeout = false;
	this.spawnOnTimeout = null;
};
DecayComponent.prototype.update = function(parent, delta) {
	this.lifetime -= delta;

	if(this.lifetime &lt; 0){
		if(this.destroyOnTimeout)
			parent.life = 0;

		if(this.spawnOnTimeout != null){}
	}
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AnimatedSpriteComponent.html">AnimatedSpriteComponent</a></li><li><a href="AudioSystem.html">AudioSystem</a></li><li><a href="BounceComponent.html">BounceComponent</a></li><li><a href="CameraSystem.html">CameraSystem</a></li><li><a href="CanvasRenderSystem.html">CanvasRenderSystem</a></li><li><a href="CanvasSpriteRenderingComponent.html">CanvasSpriteRenderingComponent</a></li><li><a href="CollisionComponent.html">CollisionComponent</a></li><li><a href="CollisionSystem.html">CollisionSystem</a></li><li><a href="DebugDrawBoundsComponent.html">DebugDrawBoundsComponent</a></li><li><a href="DebugFlockingComponent.html">DebugFlockingComponent</a></li><li><a href="FlockingComponent.html">FlockingComponent</a></li><li><a href="Game.html">Game</a></li><li><a href="GameComponent.html">GameComponent</a></li><li><a href="GameObject.html">GameObject</a></li><li><a href="GameObjectManager.html">GameObjectManager</a></li><li><a href="GravityComponent.html">GravityComponent</a></li><li><a href="InputSystem.html">InputSystem</a></li><li><a href="MoveComponent.html">MoveComponent</a></li><li><a href="PhysicsComponent.html">PhysicsComponent</a></li><li><a href="SolidComponent.html">SolidComponent</a></li><li><a href="SpriteAnimationComponent.html">SpriteAnimationComponent</a></li><li><a href="SpriteRenderingComponent.html">SpriteRenderingComponent</a></li><li><a href="SwitchComponent.html">SwitchComponent</a></li><li><a href="TerminalVelocityComponent.html">TerminalVelocityComponent</a></li><li><a href="TileComponent.html">TileComponent</a></li><li><a href="WorldBounceComponent.html">WorldBounceComponent</a></li><li><a href="WorldSystem.html">WorldSystem</a></li><li><a href="WorldWrapComponent.html">WorldWrapComponent</a></li></ul><h3>Global</h3><ul><li><a href="global.html#simplifyPaths">simplifyPaths</a></li><li><a href="global.html#Sprite">Sprite</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Wed Jan 25 2017 18:16:41 GMT+0800 (China Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
